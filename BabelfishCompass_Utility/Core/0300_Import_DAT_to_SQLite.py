"""
Import Babelfish Compass DAT file into SQLite database

This script reads the pg_import.dat file generated by Babelfish Compass
and imports it into an SQLite database.

Usage:
    python import_dat_to_sqlite.py

Configuration:
    - Modify DAT_FILE_PATH to point to your pg_import.dat file
    - Modify SQLITE_DIR to point to your SQLite database directory
    - The database name will be: MyReport-YYYY-MM-DD-HHMMSS.db
"""

import sqlite3
import csv
import os
import sys
import configparser
import logging
from datetime import datetime
from pathlib import Path

# ============================================================================
# CONFIGURATION
# ============================================================================

# Get the directory where this script is located (Core directory)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
# Go up one level to get the main directory
MAIN_DIR = os.path.dirname(SCRIPT_DIR)

# Setup logging directory
LOGS_DIR = os.path.join(MAIN_DIR, "Logs")
os.makedirs(LOGS_DIR, exist_ok=True)

# Load configuration from config.ini
CONFIG_FILE = os.path.join(MAIN_DIR, "Config", "config.ini")
config = configparser.ConfigParser()

# Check if config file exists
if not os.path.exists(CONFIG_FILE):
    print(f"[ERROR] Configuration file not found: {CONFIG_FILE}")
    print("Please ensure config.ini exists in the Config directory.")
    sys.exit(1)

config.read(CONFIG_FILE)

# Read configuration values
try:
    # Paths
    SQLITE_DIR = os.path.join(MAIN_DIR, config.get('Paths', 'sqlite_dir'))

    # Defaults
    DEFAULT_REPORT_NAME = config.get('Defaults', 'default_report_name')

    # Database
    TABLE_NAME = config.get('Database', 'table_name')

    # BabelfishCompass
    DAT_FILE_PATTERN = config.get('BabelfishCompass', 'dat_file_pattern')

except (configparser.NoSectionError, configparser.NoOptionError) as e:
    print(f"[ERROR] Configuration error: {e}")
    print("Please check your config.ini file for missing sections or options.")
    sys.exit(1)

# ============================================================================
# LOGGING SETUP
# ============================================================================

# Read logging configuration from config.ini
try:
    LOG_FORMAT = config.get('Logging', 'log_format')
    LOG_LEVEL = config.get('Logging', 'log_level')
    TIMESTAMP_FORMAT = config.get('Logging', 'timestamp_format')
    LOG_FILEMODE = config.get('Logging', 'log_filemode', fallback='w')
except (configparser.NoSectionError, configparser.NoOptionError) as e:
    # Fallback to defaults if logging section is missing
    LOG_FORMAT = '%(asctime)s [%(levelname)s] %(message)s'
    LOG_LEVEL = 'INFO'
    TIMESTAMP_FORMAT = '%Y%m%d_%H%M%S'
    LOG_FILEMODE = 'w'

# Create log filename with timestamp
timestamp = datetime.now().strftime(TIMESTAMP_FORMAT)
log_filename = f"log_0300_Import_DAT_to_SQLite_{timestamp}.log"
LOG_FILE = os.path.join(LOGS_DIR, log_filename)

# Map log level string to logging constant
log_level_map = {
    'DEBUG': logging.DEBUG,
    'INFO': logging.INFO,
    'WARNING': logging.WARNING,
    'ERROR': logging.ERROR,
    'CRITICAL': logging.CRITICAL
}
log_level_value = log_level_map.get(LOG_LEVEL.upper(), logging.INFO)

# Configure logging - file only, no console output
logging.basicConfig(
    filename=LOG_FILE,
    level=log_level_value,
    format=LOG_FORMAT,
    filemode=LOG_FILEMODE
)


# ============================================================================
# MAIN SCRIPT
# ============================================================================

def get_username():
    """Get the current Windows username"""
    return os.getenv('USERNAME')


def get_dat_file_path(report_name):
    """Construct the DAT file path based on username and report name from config"""
    username = get_username()
    return DAT_FILE_PATTERN.format(username=username, report_name=report_name)


def create_database_name(report_name):
    """Generate database name based on report name"""
    return f"{report_name}.db"


def prompt_for_report_name():
    """Prompt user for report name, default to MyReport"""
    # Check if report name was passed as command-line argument
    if len(sys.argv) > 1:
        report_name = sys.argv[1].strip()
        return report_name

    # Otherwise, prompt the user
    print("Enter report name (or press Enter for default 'MyReport'): ", end='')
    report_name = input().strip()

    if not report_name:
        report_name = DEFAULT_REPORT_NAME

    return report_name


def create_table(cursor):
    """Create the BBFCompass table with the official schema"""

    # Drop table if exists (for clean import)
    cursor.execute(f"DROP TABLE IF EXISTS {TABLE_NAME}")

    # Create table with official Babelfish Compass schema
    create_table_sql = f"""
    CREATE TABLE {TABLE_NAME} (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        babelfish_version VARCHAR(20) NOT NULL,
        date_imported TIMESTAMP NOT NULL,
        item VARCHAR(200) NOT NULL,
        itemDetail VARCHAR(200) NOT NULL,
        reportGroup VARCHAR(50) NOT NULL,
        status VARCHAR(20) NOT NULL,
        lineNr INT NOT NULL,
        appName VARCHAR(100) NOT NULL,
        srcFile VARCHAR(300) NOT NULL,
        batchNrinFile INT NOT NULL,
        batchLineInFile INT NOT NULL,
        context VARCHAR(200) NOT NULL,
        subcontext VARCHAR(200) NOT NULL,
        misc VARCHAR(20) NOT NULL,
        misc2 BIGINT NOT NULL,
        misc3 BIGINT NOT NULL
    )
    """

    cursor.execute(create_table_sql)
    logging.info(f"[OK] Table '{TABLE_NAME}' created successfully with official schema (16 columns)")


def import_dat_file(cursor, dat_file_path):
    """Import DAT file into SQLite table (no header in DAT file)"""

    if not os.path.exists(dat_file_path):
        raise FileNotFoundError(f"DAT file not found: {dat_file_path}")

    logging.info(f"Reading DAT file: {dat_file_path}")

    # Column names matching the BBFCompass table schema (excluding id)
    columns = [
        'babelfish_version',
        'date_imported',
        'item',
        'itemDetail',
        'reportGroup',
        'status',
        'lineNr',
        'appName',
        'srcFile',
        'batchNrinFile',
        'batchLineInFile',
        'context',
        'subcontext',
        'misc',
        'misc2',
        'misc3'
    ]

    # Read the DAT file (semicolon-delimited, NO HEADER)
    with open(dat_file_path, 'r', encoding='utf-8') as f:
        # Use csv.reader with semicolon delimiter
        reader = csv.reader(f, delimiter=';')

        # Prepare insert statement with placeholders (16 columns)
        placeholders = ','.join(['?' for _ in range(16)])
        column_list = ','.join(columns)
        insert_sql = f"INSERT INTO {TABLE_NAME} ({column_list}) VALUES ({placeholders})"

        # Import rows (no header to skip)
        row_count = 0
        for row in reader:
            if row and len(row) == 16:  # Ensure row has correct number of columns
                cursor.execute(insert_sql, row)
                row_count += 1

                # Progress indicator
                if row_count % 1000 == 0:
                    logging.info(f"  Imported {row_count} rows...")
            elif row:
                logging.warning(f"  Skipping row with {len(row)} columns (expected 16)")

        logging.info(f"[OK] Successfully imported {row_count} rows")
        return row_count


def main():
    """Main execution function"""

    # Prompt for report name (checks command-line args first)
    report_name = prompt_for_report_name()

    # Get username
    username = get_username()

    # Log detailed information to file
    logging.info("=" * 80)
    logging.info("BABELFISH COMPASS DAT TO SQLITE IMPORTER")
    logging.info("=" * 80)
    logging.info(f"[OK] Current user: {username}")
    logging.info(f"[OK] Report name: {report_name}")
    logging.info(f"[OK] Log file: {LOG_FILE}")

    # Construct DAT file path
    dat_file_path = get_dat_file_path(report_name)
    logging.info(f"[OK] DAT file path: {dat_file_path}")

    # Create SQLite directory if it doesn't exist
    os.makedirs(SQLITE_DIR, exist_ok=True)
    logging.info(f"[OK] SQLite directory: {SQLITE_DIR}")

    # Generate database name based on report name
    db_name = create_database_name(report_name)
    db_path = os.path.join(SQLITE_DIR, db_name)
    logging.info(f"[OK] Database name: {db_name}")
    logging.info(f"[OK] Full path: {db_path}")

    try:
        # Connect to SQLite database (creates if doesn't exist)
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        logging.info(f"[OK] Connected to SQLite database")

        # Create table with official BBFCompass schema
        create_table(cursor)

        # Import DAT file (no header in file)
        row_count = import_dat_file(cursor, dat_file_path)

        # Commit changes
        conn.commit()
        logging.info("[OK] Changes committed to database")

        # Display summary
        logging.info("=" * 80)
        logging.info("IMPORT SUMMARY")
        logging.info("=" * 80)
        logging.info(f"Database: {db_path}")
        logging.info(f"Table: {TABLE_NAME}")
        logging.info(f"Rows imported: {row_count}")

        # Query sample data
        cursor.execute(f"SELECT COUNT(*) FROM {TABLE_NAME}")
        total_rows = cursor.fetchone()[0]
        logging.info(f"Total rows in table: {total_rows}")

        logging.info("[OK] Import completed successfully!")
        logging.info("=" * 80)
        logging.info("")
        logging.info("NOTE: You may wish to delete the report files in:")
        logging.info(f"      C:\\Users\\{username}\\Documents\\BabelfishCompass\\{report_name}\\")
        logging.info("      to free up disk space, as the data is now in SQLite.")
        logging.info("=" * 80)
        logging.info("")
        logging.info(f"Log file saved to: {LOG_FILE}")

    except FileNotFoundError as e:
        logging.error(f"[ERROR] {e}")
        logging.error("")
        logging.error("Please check the report name and ensure the DAT file exists.")
        return 1

    except Exception as e:
        logging.error(f"[ERROR] {e}")
        import traceback
        traceback.print_exc()
        return 1

    finally:
        if 'conn' in locals():
            conn.close()
            logging.info("[OK] Database connection closed")

    return 0


if __name__ == "__main__":
    exit(main())

